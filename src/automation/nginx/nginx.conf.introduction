## nginx 역할 = proxy 서버로서 네트워크 요청을 받은 후, 적절한 로드밸런싱을 통해 WAS(Web Application Server, 웹 컨텐츠를 동적으로 생성하는 역할) 에 전달한 후, 정적 응답값을 네트워크를 통해 클라이언트에게 전달하는 중간 대리자.
## index.html, css, javascript와 같은 정적값을 서빙할수도 있고, proxy_pass 로서 포트포워딩을 통한 리버스 프록시(리퀘스트 요청을 받은 후, 실제 내부에 돌아가는 어플리케이션 서버에 요청을 전달해 결과를 받아서 대신 클라이언트에 리턴하는 동작)도 가능하다.
## 프록시처럼 작동하기때문에 중간에서 캐싱도 가능하고 암호화를 통한 전달도 가능.
## 정리 레퍼런스 주소 : https://brunch.co.kr/@springboot/21, https://gonna-be.tistory.com/20
## 개념 레퍼런스 강의 : https://www.youtube.com/watch?v=9t9Mp0BGnyI
## nginx ec2 환경 적용 절차 정리 레퍼런스 : https://develop-const.tistory.com/42

## nginx의 기본적인 statement 정의는 simple directive(끝이 ;로 끝나는 한 문장) 과 block directive({} 안에 들어가있는 문장) 으로 나뉜다.
## nginx option 설명들 (레퍼런스 : https://blog.dglee.co.kr/27)

############ CORE #######################
user: 
nginx process가 어느 사용자/그룹으로 동작될 것인지에 대한 설정.(root로 하면 모든 권한을 갖게 되므로 주의)

worker_processes: 
발생되는 이벤트를 처리하는 작업자 프로세스 수. (어려우면 auto로. 보통 CPU 코어수로 정함)

error_log: 
nginx 에러로그를 저장하는 파일명 지정

pid: 
nginx 실행할 때 process id 저장하는 경로 지정

########## EVENT BLOCK ######################
worker_connections:
하나의 worker process가 동시에 처리할 수 있는 커넥션 수. (예를 들어 worker_processes 가 2인데, worker_connections가 1024면 2048개의 커넥션을 처리할 수 있음. 클라이언트 커넥션수 + 프록시 대상 커넥션수)

########## HTTP ###########################
include:
특정 nginx 설정을 포함시킴. 

default_type:
기본 Content_Type을 지정함.

log_format:
작성되는 로그의 포맷 (포맷형식 주소 : https://nginx.org/en/docs/varindex.html)

access_log:
클라이언트가 log에 acess하기 위한 경로

sendfile:
리눅스 서버의 sendfile 시스템콜의 사용유무 설정(설정시 커널에 최적화 알고리즘을 통해 파일전송 속도가 빨라지며 메모리 사용 감소)

keepalive_timeout:
클라이언트의 접속 유지시간 지정.

tcp_nopush:
TCP 연결을 맺은 클라이언트에게 데이터를 즉시 보낼지, 버퍼를 두고 보낼지에 대한 설정. (on이면 즉시 보내기인데, 보안적 이슈로 권장되지 않음. 보안제외 즉각적인 전송이 더 중요하면 성능적 이점)

########## SERVER ##############################
listen:
접근 포트의 지정 (설정하여 server 블록에서 처리할 수 있게 함)

server_name:
호스트 네임 지정 (배포환경에 주소에 맞춰 설정해야 함. 해당 호스트네임으로 요청이 들어오는 것을 nginx가 프록시로 중간처리함)

access_log:
HTTP쪽과다름(저기는 접근). 로그 저장위치 설정함

error_page:
클라이언트의 HTTP요청이 error_code_list에 설정한 에러일 경우, 지정된 error_oage를 전송함.
(단, WAS에서 전달되는 페이지가 없어야 함. 예를 들어, www.example.com/nopage로 접근했을 때 해당 리소스가 없는 상태고 응답코드가 404인 경우에는 지정된 nginx의 페이지가 전달된다)

location:
end-path처럼 경로별로 어떤 리소스를 전달할 것인지에 대해서 설정하는 부분.






http {
    server { # 전달받은 요청에 대해서 어떤 서버로 전달할지 정의내리는 부분
        listen 8080; # 8080포트로 오는 요청을 주시하고 있겠다. (즉, 이 포트로 들어오는 요청을 proxy처럼 중간에서 처리한다)
        root /Users/anderson/Desktop/project; # 루트 페이지 파일경로 (!절대경로여야 함, serving하고 싶은 파일. 맨 뒤에 index.html이 생략되어있는것임)

        # url은 /numbers/~path로 유지하면서 내용물만 바꾸고 싶을 때(rewrite) 는 어떻게 하면 될까.
        rewrite ^/number/(\w+) /count/$1; ($1은 variable을 의미하며, 정규식 매칭부를 뜻한다)

        location ~* /count/[0-9] { # dynamic route에 대해서는 이렇게 정의하면 된다.
            root /Users/anderson/Desktop/project;
            try_files /index.html =404; 
        }

        location /fruits {
            # 위에 root에 대한 경로를 설정했다면, location은 다른 경로들에 대한 url을 정의하는 부분
            # 위에 /fruits라고 해놓았기 때문에, 8080포트의 /fruits로 들어오는 요청에 대한 처리를 담당하게 된다.
            
            root /Users/anderson/Desktop/project/fruits; (!절대경로여야 함. index.html이 생략되어있는 형태)
        }

        location /carbs {
            # 이렇게 경유점을 설정하면, 8080포트의 /carbs로 오는 요청에 대해서 /fruits가 전달되도록 만들 수 있다.
            alias /Users/anderson/Desktop/project/fruits;
        }

        location /vegetables {
            root /Users/anderson/Desktop/project #이렇게 할 경우, default action은 해당 폴더의 index.html을 서빙하려고 할것이다
            try_files /vegetables/veggies.html /index.html =404; # 하지만 이렇게 try_files를 설정해주면 root를 기준으로 try_files에 있는 경로의 파일을 찾아서 서빙하려고 할 것이다. 그리고도 못찾으면 (root 기준으로) index.html을 사용하게 하고, 그것조차 없으면 404코드를 내뱉게 한다(=404)
        }

        location /crops {
            return 307 /fruits # /crops로 오는 요청에 대해서 /fruits로 리다이렉트해라 redirect해라
        }
    }

    types { # 응답으로 전달하는 정적 값에 대해서 어떤식으로 브라우저가 처리해야될지에 대해 MIME-type을 정의하는 부분
        text/css       css; # 이 말은 .css 확장자를 가진 파일의 MIME-type 은 text/css어야한다고 일러두는 것과 같다.(즉, 클라이언트 네트워크에서는 response Header의 Content-Type이 text/css가 되어있을 것)
        text/html      html; # .html 확장자를 가진 파일의 MIME-type은 text/html이어야 한다고 일러두는 것과 같다.

        # 보통 위처럼 일일이 정의하기보다, 하나의 파일을 가져와서 "include" 키워드로 포함시킨다.
        include mime.types; # 해당 파일은 nginx.conf파일과 같은 레벨에 있어야 저렇게 인식시킬 수 있음.      
    }     
} 

## load balancer = round-robin 알고리즘을 내부적으로 이용하고 있음(CPU 사용시간 분배 알고리즘 https://jwprogramming.tistory.com/17).
## 아래 예시는 expose를 7777포트로 해둔 도커파일의 이미지로 컨테이너를 포트별로 1111:7777, 2222:7777 ... 이렇게 여러 컨테이너가 띄워져 있는 상황이라고 가정하자.
http {
    include mime.types;

    # 현재 로드밸런싱을 받아야 하는 remote 백엔드의 주소들을 정의한다.(현재는 로컬에서 진행중이므로 모두 다 127.0.0.1 ip로 되어있음) 
    # upstream을 묶어둔 block directive의 별칭은 하단에 location부분의 prox_pass에서 도메인으로서 사용된다.
    upstream backendserver { 
        server 127.0.0.1:1111;
        server 127.0.0.1:2222;
        server 127.0.0.1:3333;
        server 127.0.0.1:4444;
    }

    server {
        listen 8080;
        location / {
            proxy_pass htttp://backendserver/; # 위에서 정의했던 upstream 그룹에게 적절하게 요청들을 분배해서 전달한다!
        }
    }
}

// nginx 커맨드

* nginx : 서버시작
* nginx -s stop : 서버종료(워커들이 요청을 처리중이더라도 그냥 종료한다.)
* nginx -s quit : 워커 프로세스가 현재 요청 처리를 완료할 때까지 대기하고 모두 처리완료된 후에 서버 종료.
* nginx -s reload : nginx config를 새로 로드한다. 마스터 프로세스가 설정을 다시 로드하라는 요청을 받으면 설정 유효성 검사후 새로운 워커 프로세스를 시작하고, 이전 워커 프로세스에게 종료 메시지를 보내게 되고 이전 워커 프로세스는 요청을 완료하게 되면 종료된다.

